# 최대공약수(GCD), 최소공배수(LCM)

## Question

두 자연수의 최대 공약수와 최소 공배수를 계산하는 프로그램을 작성해보자.

- 최대공약수(GCD)란 두 정수 A와 B에 모두 나누어 떨어지는 가장 큰 공통의 약수를 의미한다.
- 최소공배수(LCM)란 A의 배수이면서 동시에 B의 배수가 되는 가장 작은 공통의 배수를 나타낸다.

## Input

첫 줄에는 테스트케이스의 수 **_T_**가 1이상 100이하의 자연수로 주어진다.

이후 총 **_T_**줄에 걸쳐서 한 줄에 하나의 테스트케이스에 대한 입력이 주어진다.

- 각 테스트케이스의 입력은 한 줄에 두 자연수가 공백으로 구분되어 주어진다.
- 각 자연수는 1이상 10억이하의 자연수이다.

## Output

각 테스트케이스마다 두 줄에 걸쳐 결과를 출력한다.

- 각 테스트케이스의 첫 줄에는 테스트케이스의 번호를 `**Case #%d:**` 형식으로 출력한다. 대소문자와 공백에 주의한다.
- 두 번째 줄에는 최대 공약수와 최소 공배수를 공백으로 구분하여 순서대로 출력한다.

## 입 출력 예시

**입력**

```
100
75221805 105181189
549637764 122478642
456895740 642722400
226314504 346039420
628499900 106144300
240873140 85015334
486916066 585507657
43024408 189790576
130248000 69592230
153433427 347255975
156827900 716375050
43023980 12912951
40372700 25906770
119604538 174628709
292995 464151
230413200 632535600
50116980 5734300
403400701 286111309
160755517 95157793
697110276 128892942
430698632 612347268
37429958 58968258
585864090 407660645
76204648 42515212
136258350 68995365
558755610 364140700
361927716 329542050
46883592 333440604
358633575 46532385
414012602 373106420
26296620 47962950
409940048 504942478
218479446 58563035
282290832 294852528
142221726 31700520
26754717 595267662
89364750 57054890
370214304 327975696
264227600 537919746
179921750 266781475
460955495 423393152
609031475 61028721
453009423 138088548
130276968 123635856
750876808 728961904
64672250 299120569
235976720 47409292
317274111 622234833
41204352 17978688
101825204 46061288
13641450 348462500
723374784 80280
```

**출력**

```
Case #1:
5879 1345793313255
Case #2:
24258 2775121070436
Case #3:
90780 3234821839200
Case #4:
22492 3481848644040
Case #5:
31100 2145070158700
Case #6:
21838 937719134020
Case #7:
23149 12315568057338
Case #8:
35528 229836387536
Case #9:
18090 501064056000
Case #10:
18847 2827010892475
Case #11:
56050 2004417389900
Case #12:
1919 289508361420
Case #13:
2290 456736355100
Case #14:
6337 3295942253666
Case #15:
51 2666547495
Case #16:
1467600 99308089200
Case #17:
8020 35833640700
Case #18:
13651 8454875292259
Case #19:
5407 2829136343683
Case #20:
30066 2988511753212
Case #21:
19708 13382237194872
Case #22:
2122 1040141102862
Case #23:
124705 1915189710210
Case #24:
32932 98380200568
Case #25:
33315 282191042850
Case #26:
174230 1167799224900
Case #27:
42114 2832084377700
Case #28:
24444 639539078472
Case #29:
257085 64912677075
Case #30:
27658 5585030000980
Case #31:
3570 353295089700
Case #32:
20278 10207917135248
Case #33:
21257 601910873730
Case #34:
28944 2875696705584
Case #35:
91
```

## Solve

### 알고리즘 활용하기

#### 유클리드 호제법

live 한 방법으로, 2 부터 두 자연수 중 가장 작은 자연수까지 모두 나누어 보면서 최대공약수를 구할 수 있지만, 시간 복잡도는
$$O(N)$$
이 된다.
따라서, 유클리드 호제법이라는 알고리즘을 사용하여 시간 복잡도를
$$O(log_N)$$
으로 줄여보도록 하자

최대공약수를 유클리드 호제법으로 구했다면 **최소공배수는 두수를 곱한 값을 최대공약수로 나눈값**과 같다.

```java
import java.io.*;
import java.lang.*;
import java.util.*;


public class Main {
	public static final Scanner scanner = new Scanner(System.in);

	public static void testCase(int caseIndex)
	{   //각 테스트케이스에 대하여
		int num1 = scanner.nextInt();
		int num2 = scanner.nextInt();

		// 두 숫자의 최대 공약수와 최소 공배수를 계산한다
		long gcd =  MathUtil.getGCD(num1, num2);
		long lcm =  MathUtil.getLCM(num1, num2);

		// 정답을 출력한다
		System.out.printf("Case #%d:\n", caseIndex);
		System.out.printf("%d %d\n", gcd,lcm);
	}

	public static void main(String[] args) throws Exception {
		int caseSize = scanner.nextInt();

		for (int caseIndex = 1; caseIndex <= caseSize; caseIndex += 1) {
			testCase(caseIndex);
		}
	}

}

class MathUtil{

	/**
	 * a와 b의 최대 공약수를 계산하는 함수
	 *
	 * @param a
	 * @param b
	 * @return
	 */
	static long getGCD(long a, long b)
	{
		long num = a % b;
		if(num == 0){
			return b;
		}else{
			return getGCD(b, num);
		}
	}

	/**
	 * a와 b의 최소 공배수를 계산하는 함수
	 *
	 * @param a
	 * @param b
	 * @return
	 */
	static long getLCM(long a, long b)
	{
		return a*b/getGCD(a, b);
	}
}
```
